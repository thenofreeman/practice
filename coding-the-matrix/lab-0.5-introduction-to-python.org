#+title: Lab 0.5 - Introduction to Python

* Task 0.5.1

Use Python to find the number of minutes in a week.

#+begin_src python :session
60 * 24 * 7
#+end_src

#+RESULTS:
: 10080

* Task 0.5.2

Find the remainder of 2304811 divided by 47 without using the modulo operator, %.

#+begin_src python :session
2304811 - ((2304811 // 47) * 47)
#+end_src

#+RESULTS:
: 25

* Task 0.5.3

Enter a Boolean expression to test whether the sum of 673 and 909 is divisible by 3.

#+begin_src python :session
(673 + 909) % 3 == 0
#+end_src

#+RESULTS:
: False

* Task 0.5.4

Assign the value -9 to x and 1/2 to y.

Predict the value of the following expression, then enter it to check your prediction:

#+begin_src python
2**(y+1/2) if x+10<0 else 2**(y-1/2)
#+end_src

#+begin_src python :session
x = -9
y = 1/2

2**(y+1/2) if x+10<0 else 2**(y-1/2)
#+end_src

#+RESULTS:
: 1.0

* Task 0.5.5

Write a comprehension over ={1, 2, 3, 4, 5}= whose value is the set consisting of the squares of the first five positive integers.

#+begin_src python :session
{x*x for x in {1,2,3,4,5}}
#+end_src

#+RESULTS:
: {1, 4, 9, 16, 25}

* Task 0.5.6

Write a comprehension over {0, 1, 2, 3, 4} whose value is the set consisting of the first five powers of two, starting with 20.

#+begin_src python :session
{2**x for x in {0,1,2,3,4}}
#+end_src

#+RESULTS:
: {1, 2, 4, 8, 16}

* Task 0.5.7

The value of the previous comprehension,

#+begin_src python :session
len({x*y for x in {1,2,3} for y in {2,3,4}})
#+end_src

#+RESULTS:
: 7

is a seven-element set. 

Replace {1,2,3} and {2,3,4} with two other three-elements sets so that the value becomes a nine-element set.

#+begin_src python :session
len({x*y for x in {1,2,10} for y in {1,3,4}})

#+end_src

#+RESULTS:
: 9

* Task 0.5.8

Replace the same comprehension from Task 0.5.7 with two disjoint three-element sets so that the value becomes a five-element set.

#+begin_src python :session
len({x*y for x in {0,-3,1} for y in {-1,3,-9}})
#+end_src

#+RESULTS:
: 5

* Task 0.5.9

Assume that S and T are assigned sets. Without using the intersection operator &, write a comprehension over S whose value is the intersection of S and T.

Hint: Use a membership test in a filter at the end of the comprehension.

Try out your comprehension with =S = {1,2,3,4}= and =T = {3,4,5,6}=.

#+begin_src python :session
S = {1,2,3,4}
T = {3,4,5,6}

{s for s in S if s in T}
#+end_src

#+RESULTS:
: {3, 4}

* Task 0.5.10

Write an expression whose value is the average of the elements of the list [20, 10, 15, 75].

#+begin_src python :session
L = [20, 10, 15, 75]
sum(L)/len(L)
#+end_src

#+RESULTS:
: 30.0

* Task 0.5.11

Write a double list comprehension over the lists ['A','B','C'] and [1,2,3] whose value is the list of all possible two-element lists [letter, number].

That is, the value is [['A', 1], ['A', 2], ['A', 3], ['B', 1], ['B', 2],['B', 3], ['C', 1], ['C', 2], ['C', 3]]

#+begin_src python :session :results verbatim
L = ['A', 'B', 'C']
M = [1, 2, 3]

[[l, m] for l in L for m in M]
#+end_src

#+RESULTS:
: [['A', 1], ['A', 2], ['A', 3], ['B', 1], ['B', 2], ['B', 3], ['C', 1], ['C', 2], ['C', 3]]

* Task 0.5.12

Suppose LofL has been assigned a list whose elements are themselves lists of numbers. Write an expression that evaluates to the sum of all the numbers in all the lists.

The expression has the form =sum([sum(...= and includes one comprehension.

Test your expression after assigning =[[.25, .75, .1], [-1, 0], [4, 4, 4, 4]]= to LofL.

Note that your expression should work for a list of any length.

#+begin_src python :session
LofL = [[.25, .75, .1], [-1, 0], [4, 4, 4, 4]]

sum([sum(L) for L in LofL])
#+end_src

#+RESULTS:
: 16.1

* Task 0.5.13

Find out what happens if the length of the left-hand side list does not match the length of the right-hand side list when unpacking lists.

#+begin_src python :session
[x, y, z] = [4, 5, 6, 7]
#+end_src

#+RESULTS:
: error: too many items to unpack


* Task 0.5.14
Suppose S is a set of integers, e.g. ={−4, −2, 1, 2, 5, 0}=.

Write a triple comprehension whose value is a list of all three-element tuples (i, j, k) such that i, j, k are elements of S whose sum is zero.

#+begin_src python :session :results verbatim
S = {-4, -2, 1, 2, 5, 0}

[(i, j, k) for i in S for j in S for k in S if i+j+k == 0]
#+end_src

#+RESULTS:
: [(0, 0, 0), (0, 2, -2), (0, -2, 2), (1, 1, -2), (1, -2, 1), (2, 0, -2), (2, 2, -4), (2, -4, 2), (2, -2, 0), (-4, 2, 2), (-2, 0, 2), (-2, 1, 1), (-2, 2, 0)]

* Task 0.5.15
Modify the comprehension of the previous task so that the resulting list does not include (0, 0, 0). Hint: add a filter.

#+begin_src python :session :results verbatim
S = {-4, -2, 1, 2, 5, 0}

[(i, j, k) for i in S for j in S for k in S if i+j+k == 0 if (i, j, k) != (0,0,0)]
#+end_src

#+RESULTS:
: [(0, 2, -2), (0, -2, 2), (1, 1, -2), (1, -2, 1), (2, 0, -2), (2, 2, -4), (2, -4, 2), (2, -2, 0), (-4, 2, 2), (-2, 0, 2), (-2, 1, 1), (-2, 2, 0)]

* Task 0.5.16

Further modify the expression so that its value is not the list of all such tuples but is the first such tuple.

#+begin_src python :session :results verbatim
S = {-4, -2, 1, 2, 5, 0}

[(i, j, k) for i in S for j in S for k in S if i+j+k == 0 if (i, j, k) != (0,0,0)][0]
#+end_src

#+RESULTS:
: (0, 2, -2)

* Task 0.5.17

Find an example of a list L such that len(L) and len(list(set(L))) are different.

#+begin_src python :session
L = [3, 3, 5] # any list that has a duplicate item

len(L) == len(list(set(L)))
#+end_src

#+RESULTS:
: False

* Task 0.5.18

Write a comprehension over a range of the form range(n) such that the value of the comprehension is the set of odd numbers from 1 to 99.

#+begin_src python :session
{ x for x in range(100) if x % 2 != 0 }
#+end_src

#+RESULTS:
: {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99}

* Task 0.5.19

Assign to L the list consisting of the first five letters, ['A','B','C','D','E'].

Next, use L in an expression whose value is

=[(0, ’A’), (1, ’B’), (2, ’C’), (3, ’D’), (4, ’E’)]=

Your expression should use a range and a zip, but should not use a comprehension.

#+begin_src python :session :results verbatim
L = ['A','B','C','D','E']
list(zip(range(5), L))
#+end_src

#+RESULTS:
: [(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D'), (4, 'E')]

* Task 0.5.20

Starting from the lists [10, 25, 40] and [1, 15, 20], write a comprehension whose value is the three-element list in which the first element is the sum of 10 and 1, the second is the sum of 25 and 15, and the third is the sum of 40 and 20.

Your expression should use zip but not list.

#+begin_src python :session :results verbatim
L = [10, 25, 40]
M = [1, 15, 20]

[l+m for (l, m) in zip(L, M)]
#+end_src

#+RESULTS:
: [11, 40, 60]

* Task 0.5.21

Suppose dlist is a list of dictionaries and k is a key that appears in all the dictionaries in dlist. Write a comprehension that evaluates to the list whose ith element is the value corresponding to key k in the ith dictionary in dlist.

Test your comprehension with some data. Here are some example data:

#+begin_src python :session :results verbatim
dlist = [{'James':'Sean', 'director':'Terence'}, {'James':'Roger', 'director':'Lewis'}, {'James':'Pierce', 'director':'Roger'}]
k = 'James'

[x[k] for x in dlist]
#+end_src

#+RESULTS:
: ['Sean', 'Roger', 'Pierce']

* Task 0.5.22

Modify the comprehension in Task 0.5.21 to handle the case in which k might not appear in all the dictionaries.

The comprehension evaluates to the list whose ith element is the value corresponding to key k in the ith dictionary in dlist if that dictionary contains that key, and 'NOT PRESENT' otherwise.

Test your comprehension with k = 'Bilbo' and k = 'Frodo' and with the following list of dictionaries:

#+begin_src python :session
dlist = [{'Bilbo':'Ian','Frodo':'Elijah'}, {'Bilbo':'Martin','Thorin':'Richard'}]
# k = 'Bilbo'
k = 'Frodo'

[x[k] if k in x else 'NOT PRESENT' for x in dlist]
#+end_src

#+RESULTS:
| Elijah | NOT PRESENT |

* Task 0.5.23

#+begin_src python :session
#+end_src

* Task 0.5.24

#+begin_src python :session
#+end_src

* Task 0.5.25

#+begin_src python :session
#+end_src

* Task 0.5.26

#+begin_src python :session
#+end_src

* Task 0.5.27

#+begin_src python :session
#+end_src

* Task 0.5.28

#+begin_src python :session
#+end_src

* Task 0.5.29

#+begin_src python :session
#+end_src

* Task 0.5.30

#+begin_src python :session
#+end_src

* Task 0.5.31

#+begin_src python :session
#+end_src

* Task 0.5.32

#+begin_src python :session
#+end_src
